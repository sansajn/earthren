# About
Bunch of earth rendering and samples to create a program capable to render earth surface based on satelite data.

# How to build

> **note**: We expect *Ubuntu 22.04 LTS* as operating system.

Install dependencies with
```bash
sudo apt install libtiff-dev libmagick++-dev libtiff-dev
```
command and build with
```bash
scons -j8
```
command. We can optionally build specific sample with
```
scons -j8 SAMPLE-NAME
```
command (e.g. `scons -j8 height_sinxy`).

# Samples

## `height_map`
`Height_map` sample shows how to render terrain based on height map texture (*TIFF* file). 
![[height_map.png]]

The sample is based on previous [[#`height_sinxy_normals`]] sample code. There is just one quad in scene and also XY axis are not scaled and Z (heights) is scaled by a factor of $100$.

See previous [[#`height_sinxy_normals`]] sample to get an idea how artificial terrain (heights generated by a function) can be rendered. In this sample instead of computed data we are using real world height map (from a Prague area for now).

For other reference, see [[OpenGL ES 3.0 Programming Guide#Rendering Terrain with Vertex Texture Fetch]] sample where normals are calculated directly in a vertex shader program.

What is new:
- TIFF file support (libtiff)
- spdlog logging library used
- direction light visualization (press `l` key)
- normals visualization (press `n`)
- outline visuali<ation (press `o`)
- usage of general geometry shaders `to_line.gs`, `to_outline.gs`
- free-camera implementation

## `geoms_plane`
Visualization of normals for a plane. We found a workaround for [[#`gs_triangle_broken`]] issue so there are not any visible artifacts anymore.
![[geoms_plane.png]]

What is new:
- unified `to_line_v0.gs` shader program
- unified `to_normal.gs` shader program

We later found that this workaround is not always working (outline visualization still produce artifacts when the camera is close enough).

## `gs_triangle_broken`

The sample show geometry shader program artifacts for a simple quad with a camera, see
![[gs_artifact_sample.png]]
**Figure**: Artifacts while rendering normals in geometry shader program.

This issue affects all samples using geometry shader (normals, height_map, ...).

## `normals`

`Normals` sample shown how to visualize computed normals. It is based on [[#`height_sinxy_normals`]] sample.

![](docasset/normals.png)

What is new:
- geometry shader used
- two shader program used
- render features used (e.g. normals)
- events features used (`zoom_in` event)

## `height_sinxy_normals`

`Height_sinxy_normals` shows how to read heights and calculate normals out of 16bit height map in a vertex shader program. The sample is based on previous [[#`height_sinxy_map`]] sample. 

![](docasset/height_sinxy_normals.png)

What is new:
- 16bit height map used
- shows how to use indices (IBO) for a mesh creation.
- use depth buffer (`GL_DEPTH_TEST`)
- use `GL_CULL_FACE` testing

## `height_sinxy_normals_fce`

This sample is a modification of [[#`height_sinxy_normals`]] where normals are not calculated from height map, but by exact function.  See [[#`height_sinxy_map`]] sample for $sinxy$ function description.

![](docasset/height_sinxy_normals_fce.png)

## `height_sinxy_map`

`Height_sinxy_map` sample is similar to `plot_sinxy` sample, but instead of calculating $z$ value in a vertex shader we want to have a height map (generated in CPU part of the program by $z=\sin(x) \cdot \sin(y)$ for $x,y \in [0, \pi]$ equation).

![](docasset/height_sinxy_map.png)

## `plot_sinxy`

This sample is similar to previous [[#`plot_sinxy`]] but instead of directional light, fragment color is set based on computed height.

![](docasset/plot_sinxy.png)

## `height_sinxy`

`Height_sinxy` sample shows how to calculate terrain heights (z coordinate) for xy-axis quad. Heights are generated by $z=\sin(x) \cdot \sin(y)$ for $x,y \in [0, \pi]$ equation in a vertex shader program. Together with heights we calculate also normals for a directional light computing in a fragment shader program.

![](docasset/height_sinxy.png)

## `map_camera`

`Map_camera` sample shows orbital camera implementation allows to rotate around z-axis and x-axis with a mouse move. Sample is based on previous `xy_plane_grid_textured` sample.

![](docasset/map_camera.jpg)


## `xy_plane_grid_textured`

`Xy_plane_grid_textured.cpp` shows grid of xy_planes the same as previous `xy_plane_grid.cpp` sample but with a texture applied.

The problem there is that pane is not smooth it has a kind of momentum. Affected samples are `xy_plane_grid.cpp`, `xy_plane_grid` and `xy_plane_panzoom` samples.

Another issue is that it is hard to diagnose issues in a shader program, see issue 1.

ToDo:
- rewrite pan functionality
- use VAOs (see `map_camera` as an example)


Then next step is to implement a camera which would allow smooth pane and zoom. I would like to implement *Proland* like camera.

Then next step is to add heights, I need to figure out area for sample tiles (see `data/tiles`), download heights for that area and spit it to tiles. Then modify shader to add texture (ortho) based heights (in this step without any noise or upsampling).

## `xy_plane_grid`

Shows grid of xy_planes with a zoom and pane features. There is not any camera implementation there.

The problem there is that pane is not smooth it has a kind of momentum. Affected samples are `xy_plane_grid` and `xy_plane_panzoom` samples.

ToDo:
- rewrite pan functionality

Next step is to implement a grid of xy_planes rendered with a image inside (instead fixed color). To see how to render a image see `texture_storage` sample and how to render to a xy plane see `xy_plane_texture` sample.

Then Next step is to implement a camera which would allow smooth pane and zoom.

## `xy_plane_texture`

Shows how to render xy plane fillet with an image

Problems: 
	- we should use VAOs


## `texture_storage`

Shows how to render a picture to screen.

Issues:
- VAOs are used incorrect way in a sample, see `map_camera` sample to learn how to use it

## `xy_plane_panzoom`

xy plane with zoom and pane capabilities


## `xy_plane`

Just a simple red xy plane rendered.


# Code Formatting

Formatting source code is done by `.clang-format` configuration file. To see LLVM style defaults run 

```bash
clang-format -style=llvm -dump-config > .clang-format
```

command.
